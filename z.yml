docker:
    cmd:            sudo docker
#    image_source:   ~
#    image_dir:      ~
    images:
        mysql:      mysql
        redis:      redis
        solr:       solr
        php5_fpm:   php5_fpm
        nginx:      nginx
        varnish:    varnish
    containers: []
    ports:
        mysql:      3306
        redis:      6379
        solr:       8983
        varnish:    81
        nginx:      80

    links:
        php5_fpm:   ['mysql', 'redis', 'solr']
        nginx:      ['php5_fpm']
        varnish:    ['nginx']

    volumes:
        php5_fpm:   [/var/www, /home]
        nginx:      [/var/www, /home]

tasks:
    docker.image:
        help: |
            Copies image source files from the docker.image_source location, so they are ready to build.

            The purpose of copying the image files is hooking in intermediate scripts that alter the Dockerfile or
            the assets of the images. You can use this to add your custom config files, e.g.:

                docker.image:
                    post:
                        - ?(image == "varnish") cp etc/varnish/default.vcl >> $(docker.image_dir)/etc/varnish/default.vcl
        set:
            image: ? "ALL"
        unless: image != "ALL" && is_dir(docker.image_dir . "/" . image)
        pre:
            - '[ -d $(docker.image_dir) ] || mkdir $(docker.image_dir)'
        do:
            - ?(image == "ALL") for d in $(docker.containers); do z $(z.opts) docker:image $d; done;
            - ?(image != "ALL") cp -rv $(docker.image_source)/$(image) $(docker.image_dir)/$(image)

    docker.rebuild:
        help: |
            Rebuild images from the image source files

            You can pass the --force to force the images to be recopied.
        set: { image: ? "ALL" }
        pre:
            - ?(image != "ALL") @docker.image
        do:
            - ?(image == "ALL") set -e; for d in $(docker.containers); do z $(z.opts) docker:rebuild $d; done;
            - ?(image != "ALL") $(docker.cmd) build -t $(image) $(docker.image_dir)/$(image);

    docker.restart:
        set:
            container: ? "ALL"
        do:
            - |
                ?(container == "ALL")
                    set -e;                                     \
                    for d in $(docker.containers); do           \
                        z $(z.opts) docker:rebuild $d;          \
                        z $(z.opts) docker:restart $d;          \
                    done;
            - ?(container != "ALL") @docker.kill
            - ?(container != "ALL") @docker.start

    docker.kill:
        set:
            container: ? "ALL"
        do: |
            $(docker.cmd) rm -f $(container == "ALL" ? docker.container_names : docker.container_name(container)) || true

    docker.start:
        set:
            container: ? "ALL"
        do:
            - ?(container == "ALL") @_docker.start_all
            - ?(container != "ALL") @_docker.start_container

    _docker.start_all: |
        set -e;
        for i in $(docker.container_names); do
          z $(z.opts) docker:start $i
        done;

    _docker.start_container:
        set:
            container: ?
        do: |
#            cd docker-images;
            $(docker.cmd) run \
                $(docker.run.ports container)   \
                $(docker.run.links container)   \
                $(docker.run.volumes container) \
                --name "$(docker.container_name container)"           \
                -d                              \
                $(docker.image container)

    docker.status:
        - $(docker.cmd) inspect --format '{{ .Name }} {{ .NetworkSettings.IPAddress }}' $(docker.container_names) | column -t

    docker.shell:
        help: Open a shell to a running docker container
        set:
            container: ?
            shell: ? "/bin/bash"
            interactive: true
        do:
            - $(docker.cmd) exec -ti $(container) "/bin/bash"
